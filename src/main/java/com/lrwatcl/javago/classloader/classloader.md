# 类加载
## 生命周期
| 概念 | 说明 |
| :--- | :--- |
| 加载 | 通过类的全限定名称获取定义此类的二进制字节流，将这个字节流代表的静态存储结构转化为方法区的运行时数据结构，同时在内存中生成一个java.lang.Class对象，作为方法区这个类的各种数据的访问入口 |  
| 验证 | 验证是连接的第一步，该阶段保证字节流符合虚拟机规范的全部约束 |
| 准备 | 给函数的实际参数总是在应用这个函数之前求值 |
| 解析 | 不求值给函数的实际参数，除非它们在函数体内实际上被用到了 |
| 初始化 | 传值调用中实际参数被求值，其值被绑定到函数中对应的变量上（通常是把值复制到新内存区域）。如果函数或过程能把值赋给它的形式参数，则被赋值的只是局部拷贝 -- 就是说，在函数返回后调用者作用域里的曾传给函数的任何东西都不会变 |
| 使用 | 传递给函数的是它的实际参数的隐式引用而不是实参的拷贝。通常函数能够修改这些参数（比如赋值），而且改变对于调用者是可见的 |  
| 卸载 | 与传引用调用不同，对于调用者而言在被调用函数里修改参数（赋值：赋值是给变量绑定一个新对象，而不是改变对象）是没有影响的，但修改了对象，调用者就可以看到变化（因为对象是共享的，没有拷贝） |

加载->验证->准备->解析->初始化->使用->卸载  
加载，验证，准备，初始化，卸载 这五个阶段顺序是固定的，解析阶段不一定，可能在初始化阶段后，为了支持Java的动态绑定（运行时绑定）特性  
Java虚拟机规范没有定义什么时机开始加载阶段，但严格规定了初始化阶段的时机：
* new,getstatic,putstatic,invokestatic 这四个字节码指令，如果类型没有初始化，则触发初始化阶段。四个字节码指令的典型Java代码场景： 
    - new 实例化对象
    - 读取or设置类型的静态字段（final修饰，在编译器把结果放入常量池的字段除外）
    - 调用类型的静态方法
* 使用Java.lang.reflect包的方法进行反射调用，如果类型没有初始化，则触发初始化阶段。
* 初始化类型时，如果父类没有初始化，则触发父类初始化阶段。
* 虚拟机启动时，用户需要指定一个主类（main()方法的类），虚拟机会先初始化这个类
* JDK7的动态语言支持特性，如果Java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic,REF_newInvokeSpecial四种类型的方法句柄，且方法句柄对应的类型没有初始化，则进行初始化
* JDK8的默认方法（default修饰的接口方法），如果有接口的实现类发生了初始化，则接口需要在其之前初始化  
以上的场景称为主动引用，除此之外，所有引用类型的方法都不会触发初始化称为被动引用
